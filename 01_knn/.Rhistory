library(rpivotTable)
library(knitr)
library(kableExtra)
library(randomcoloR)
library(plotly)
iris_dt <- as.data.table(iris)
tutorial_options(exercise.timelimit = 60)
tutorial_options(exercise.eval = T)
tutorial_options(exercise.checker = checkr::check_for_learnr)
knitr::opts_chunk$set(echo = TRUE
)
datatable(iris,
filter = "top",
options = list(autoWidth = T))
library(randomcoloR)
# collect unique values of each of the first 3 columns in a list
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for each of the first 3 columns
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the first 3 columns for each distinct values
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
}
DT1
library(learnr)
library(tidyverse)
library(DT)
library(rpivotTable)
library(knitr)
library(kableExtra)
library(randomcoloR)
library(plotly)
library(data.table)
iris_dt <- as.data.table(iris)
tutorial_options(exercise.timelimit = 60)
tutorial_options(exercise.eval = T)
tutorial_options(exercise.checker = checkr::check_for_learnr)
knitr::opts_chunk$set(echo = TRUE
)
library(randomcoloR)
# collect unique values of each of the first 3 columns in a list
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for each of the first 3 columns
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the first 3 columns for each distinct values
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
}
DT1
library(randomcoloR)
# note that iris_dt is a data.table object
# collect unique values of Species
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for unique species
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the Species
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
}
DT1
library(randomcoloR)
# note that iris_dt is a data.table object
# collect unique values of Species
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for unique species
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the Species
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
DT1
levs %>%
kableExtra::cell_spec(format = "html", background = cols) %>%
t() %>%
knitr::kable(escape = F, caption = "Species") %>%
kableExtra::kable_styling()
library(rpivotTable)
rpivotTable(iris_dt,
rows = c("Species"),
aggregatorName = "Count",
rendererName = "Table")
rpivotTable(iris_dt)
var1 <- "Mc1"
var2 <- "chilled"
val <- CO2 %>%
dplyr::filter(Plant == var1) %>%
dplyr::filter(Treatment == var2) %>%
dplyr::count() %>%
as.integer()
var1 <- "Mc1"
var2 <- "chilled"
val <- CO2 %>%
dplyr::filter(Plant == var1) %>%
dplyr::filter(Treatment == var2) %>%
dplyr::count() %>%
as.integer()
var1 <- "Mc1"
var2 <- "chilled"
val <- CO2 %>%
dplyr::filter(Plant == var1) %>%
dplyr::filter(Treatment == var2) %>%
dplyr::count() %>%
as.integer()
val
var1 <- "Mc1"
var2 <- "chilled"
val <- CO2 %>%
dplyr::filter(Plant == var1) %>%
dplyr::filter(Treatment == var2) %>%
dplyr::count() %>%
as.integer()
val
var1 <- "setosa"
#var2 <- "chilled"
iris_dt[Species == "setosa", .N]
#val <- CO2 %>%
#  dplyr::filter( == var1) %>%
#  dplyr::filter(Treatment == var2) %>%
#  dplyr::count() %>%
#  as.integer()
library(learnr)
library(tidyverse)
library(DT)
library(rpivotTable)
library(knitr)
library(kableExtra)
library(randomcoloR)
library(plotly)
tutorial_options(exercise.timelimit = 60)
tutorial_options(exercise.eval = T)
tutorial_options(exercise.checker = checkr::check_for_learnr)
knitr::opts_chunk$set(echo = TRUE
)
var1 <- "Mc1"
var2 <- "chilled"
val <- CO2 %>%
dplyr::filter(Plant == var1) %>%
dplyr::filter(Treatment == var2) %>%
dplyr::count() %>%
as.integer()
val
var1 <- "setosa"
#var2 <- "chilled"
iris_dt[Species == "setosa", .N]
val <- iris_dt %>%
dplyr::filter( Species == var1) %>%
dplyr::count() %>%
as.integer()
var1 <- "setosa"
#var2 <- "chilled"
iris_dt[Species == "setosa", .N]
val <- iris_dt %>%
dplyr::filter( Species == var1) %>%
dplyr::count() %>%
as.integer()
val
for (i in 1:length(CO2))
{
coll <- CO2[[i]]
class(coll) %>%
knitr::kable(col.names = NULL, caption = paste(names(CO2)[i], ":", sep = "")) %>%
print()
}
summary(iris_dt) %>%
knitr::kable() %>%
kableExtra::kable_styling()
vars <- names(iris_dt)[1:4]
plotlyOutput("bar_1")
selectInput("var_1", label = "Variable:",
choices = vars, selected = vars[1])
selectInput("var_2", label = "Category:",
choices = levs, selected = vars[1])
# Chunk 1: setup
library(learnr)
library(tidyverse)
library(DT)
library(rpivotTable)
library(knitr)
library(kableExtra)
library(randomcoloR)
library(plotly)
library(data.table)
iris_dt <- as.data.table(iris)
tutorial_options(exercise.timelimit = 60)
tutorial_options(exercise.eval = T)
tutorial_options(exercise.checker = checkr::check_for_learnr)
knitr::opts_chunk$set(echo = TRUE
)
# Chunk 2: DT2
# note that iris_dt is a data.table object
# collect unique values of Species
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for unique species
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the Species
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
DT1
# Chunk 3: levels1
levs %>%
kableExtra::cell_spec(format = "html", background = cols) %>%
t() %>%
knitr::kable(escape = F, caption = "Species") %>%
kableExtra::kable_styling()
# Chunk 4: rpt1
rpivotTable(iris_dt)
# Chunk 5: vars
var1 <- "setosa"
#var2 <- "chilled"
val1 <- iris_dt[Species == "setosa", .N]
val2 <- iris_dt %>%
dplyr::filter( Species == var1) %>%
dplyr::count() %>%
as.integer()
val1
val2
# Chunk 6: sum1
summary(iris_dt) %>%
knitr::kable() %>%
kableExtra::kable_styling()
# Chunk 7
vars <- names(iris_dt)[1:4]
plotlyOutput("bar_1")
selectInput("var_1", label = "Variable:",
choices = vars, selected = vars[1])
selectInput("var_2", label = "Category:",
choices = levs, selected = vars[1])
?geom_histogram
vars <- names(iris_dt)[1:4]
plotlyOutput("scatter_1")
selectInput("var_1", label = "Variable 1:",
choices = vars, selected = vars[1])
selectInput("var_2", label = "Variable 2:",
choices = vars, selected = vars[2])
output$scatter_1 <- renderPlotly({
p <-  ggplot(iris_dt) +
geom_point(mapping = aes(x = input$var_1,
y = input$var_2,
color = factor(iris_dt[["Species"]]),
text = paste("Species", ": ", iris_dt[["Species"]]))) +
guides(color=guide_legend(title=NULL))
ggplotly(p, tooltip = c("text", "x", "y"))
})
output$scatter_1 <- renderPlotly({
p <-  ggplot(iris_dt) +
geom_point(mapping = aes(x = input$var_4,
y = input$var_5,
color = factor(iris_dt[["Species"]]),
text = paste("Species", ": ", iris_dt[["Species"]]))) +
guides(color=guide_legend(title=NULL))
ggplotly(p, tooltip = c("text", "x", "y"))
})
# note that iris_dt is a data.table object
# collect unique values of Species
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for unique species
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the Species
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
DT1
DT::datable(iris_dt)
DT::datatable(iris_dt)
output$bar_1 <- renderPlotly({
irissub <- iris_dt %>%
#dplyr::filter( Species == input$var_2)
dplyr::filter()
p <- ggplot(irissub, aes(irissub[[input$var_1]])) +
geom_histogram(bins = input$var_3) +
coord_cartesian(ylim=c(0,50)) +
labs(x = input$var_1) +
facet_wrap(~ Species, nrow = length(levs))
ggplotly(p)
})
vars <- names(iris_dt)[1:4]
plotlyOutput("bar_1")
selectInput("var_1", label = "Variable:",
choices = vars, selected = vars[1])
selectInput("var_2", label = "Category:",
choices = levs, selected = vars[1])
sliderInput("var_3", label = "Number of Bins", min = 1, max = 10, value = 5, width = 300)
library(learnr)
library(widgetframe)
#library(revealjs)
library(shiny)
library(tidyverse)
library(DT)
library(rpivotTable)
library(knitr)
library(kableExtra)
library(randomcoloR)
library(plotly)
library(data.table)
library(gridExtra)
iris_dt <- as.data.table(iris)
#tutorial_options(exercise.timelimit = 60)
#tutorial_options(exercise.eval = T)
#tutorial_options(exercise.checker = checkr::check_for_learnr)
rmarkdown::knitr_options_html(fig_width = 10, fig_height = 10, fig_retina = 2, keep_md = FALSE, dev = "png")
knitr::opts_chunk$set(echo = FALSE
)
# note that iris_dt is a data.table object
# collect unique values of Species
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for unique species
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the Species
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
#DT1
var1 <- "setosa"
#var2 <- "chilled"
val1 <- iris_dt[Species == "setosa", .N]
val2 <- iris_dt %>%
dplyr::filter( Species == var1) %>%
dplyr::count() %>%
as.integer()
summary(iris_dt) %>%
knitr::kable() %>%
kableExtra::kable_styling()
vars <- names(iris_dt)[1:4]
plotlyOutput("bar_1")
selectInput("var_1", label = "Variable:",
choices = vars, selected = vars[1])
#selectInput("var_2", label = "Category:",
#            choices = levs, selected = vars[1])
sliderInput("var_3", label = "Number of Bins", min = 1, max = 10, value = 5, width = 300)
output$bar_1 <- renderPlotly({
irissub <- iris_dt %>%
#dplyr::filter( Species == input$var_2)
dplyr::filter()
p1 <- ggplot(irissub, aes(irissub[[input$var_1]])) +
geom_histogram(bins = input$var_3) +
coord_cartesian(ylim=c(0,50)) +
labs(x = input$var_1) +
facet_wrap(~ Species, nrow = length(levs))
p2 <- ggplot(irissub, aes(x = irissub[[input$var_1]], y = Species)) +
geom_boxplot()
#p <- gridExtra::grid.arrange(p1, p2, ncol = 2)
#ggplotly(p)
subplot(p1, p2, nrow = 4)
})
vars <- names(iris_dt)[1:4]
plotlyOutput("bar_1")
selectInput("var_1", label = "Variable:",
choices = vars, selected = vars[1])
#selectInput("var_2", label = "Category:",
#            choices = levs, selected = vars[1])
sliderInput("var_3", label = "Number of Bins", min = 1, max = 10, value = 5, width = 300)
output$bar_1 <- renderPlotly({
irissub <- iris_dt %>%
#dplyr::filter( Species == input$var_2)
dplyr::filter()
p1 <- ggplot(irissub, aes(irissub[[input$var_1]])) +
geom_histogram(bins = input$var_3) +
coord_cartesian(ylim=c(0,50)) +
labs(x = input$var_1) +
facet_wrap(~ Species, nrow = length(levs))
p2 <- ggplot(irissub, aes(x = irissub[[input$var_1]], y = Species)) +
geom_boxplot()
#p <- gridExtra::grid.arrange(p1, p2, ncol = 2)
#ggplotly(p)
subplot(p1, p2, nrow = 4)
})
vars <- names(iris_dt)[1:4]
plotlyOutput("bar_1")
selectInput("var_1", label = "Variable:",
choices = vars, selected = vars[1])
#selectInput("var_2", label = "Category:",
#            choices = levs, selected = vars[1])
sliderInput("var_3", label = "Number of Bins", min = 1, max = 10, value = 5, width = 300)
output$bar_1 <- renderPlotly({
irissub <- iris_dt %>%
#dplyr::filter( Species == input$var_2)
dplyr::filter()
p1 <- ggplot(irissub, aes(irissub[[input$var_1]])) +
geom_histogram(bins = input$var_3) +
coord_cartesian(ylim=c(0,50)) +
labs(x = input$var_1) +
facet_wrap(~ Species, nrow = length(levs))
p2 <- ggplot(irissub, aes(x = irissub[[input$var_1]], y = Species)) +
geom_boxplot()
#p <- gridExtra::grid.arrange(p1, p2, ncol = 2)
#ggplotly(p)
subplot(p1, p2, nrow = 4)
})
# note that iris_dt is a data.table object
# collect unique values of Species
levs <- iris_dt[,levels(Species)]
# create random and distinctive colors for unique species
cols <- randomcoloR::distinctColorPalette(length(levs))
# shuffle the rows
iris_shuf <- dplyr::sample_frac(iris_dt, 1)
# create the datatable
DT1 <- DT::datatable(iris_shuf,
filter = "top",
options = list(autoWidth = T))
# change the background colors of the Species
DT1 <- DT::formatStyle(DT1,
"Species",
backgroundColor = DT::styleEqual(levs,
cols)
)
#DT1
levs %>%
kableExtra::cell_spec(format = "html", background = cols) %>%
t() %>%
knitr::kable(escape = F, caption = "Species") %>%
kableExtra::kable_styling()
rpivotTable(iris_dt,
rows = c("Species"),
#cols = "Treatment",
aggregatorName = "Count",
rendererName = "Table")
var1 <- "setosa"
#var2 <- "chilled"
val1 <- iris_dt[Species == "setosa", .N]
val2 <- iris_dt %>%
dplyr::filter( Species == var1) %>%
dplyr::count() %>%
as.integer()
summary(iris_dt) %>%
knitr::kable() %>%
kableExtra::kable_styling()
vars <- names(iris_dt)[1:4]
plotlyOutput("bar_1")
selectInput("var_1", label = "Variable:",
choices = vars, selected = vars[1])
#selectInput("var_2", label = "Category:",
#            choices = levs, selected = vars[1])
sliderInput("var_3", label = "Number of Bins", min = 1, max = 10, value = 5, width = 300)
output$bar_1 <- renderPlotly({
irissub <- iris_dt %>%
#dplyr::filter( Species == input$var_2)
dplyr::filter()
p1 <- ggplot(irissub, aes(irissub[[input$var_1]])) +
geom_histogram(bins = input$var_3) +
coord_cartesian(ylim=c(0,50)) +
labs(x = input$var_1) +
facet_wrap(~ Species, nrow = length(levs))
p2 <- ggplot(irissub, aes(x = irissub[[input$var_1]], y = Species)) +
geom_boxplot()
#p <- gridExtra::grid.arrange(p1, p2, ncol = 2)
#ggplotly(p)
subplot(p1, p2, nrow = 4)
})
?iris
help(iris)
help(iris)
quiet = "--quiet" %in% commandArgs(FALSE)
